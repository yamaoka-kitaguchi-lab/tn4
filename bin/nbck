#!/usr/bin/env python3

"""

NBCK - NetBox Consistency Check

NBCK is a command-line utility to check and repair NetBox registration errors.
This makes sure NetBox for integrity and consistency just like the fsck command does for Linux filesystem.

$ PATH=$HOME/tn4-player/bin:$PATH
$ nbck --force-repair --verbose

Since: March 2022
See: https://github.com/yamaoka-kitaguchi-lab/tn4-player

"""

import click
from rich import box
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Prompt, Confirm
from rich.table import Table
import sys
from time import sleep


class NBCK:
    def __init__(self) -> None:
        self.console = Console(log_time_format="%Y-%m-%dT%H:%M:%S")
        self.n_total_problems = 0
        self.master_slave_tag_problems = None
        self.wifi_tag_problems = None

    def load_inventories(self, verbose=False) -> None:
        self.console.log("NBCK - NetBox Consistency Check")
        with self.console.status("[bold]Fetching the latest inventories from NetBox (netbox.m.noc.titech.ac.jp)..."):
            sleep(0.5)  # dummy
            self.console.log("Fetched all VLANs")
            sleep(0.5)  # dummy
            self.console.log("Fetched all IP Addresses")
            sleep(0.5)  # dummy
            self.console.log("Fetched all Devices")
            sleep(0.5)  # dummy
            self.console.log("Fetched all Interfaces")


    def full_check(self, verbose=False) -> None:
        with self.console.status("[bold]Finding broken consistency..."):
            self.__check_master_slave_tag_consistency()
            n_problems = len(self.master_slave_tag_problems)
            self.n_total_problems += n_problems
            self.console.log(f"Verified Master/Slave tag consistency ({n_problems} problems found)")

            self.__check_wifi_tag_consistency()
            n_problems = len(self.wifi_tag_problems)
            self.n_total_problems += n_problems
            self.console.log(f"Verified Wi-Fi tag consistency ({n_problems} problems found)")

        tbl_idx_from = 0
        all_problems = [self.master_slave_tag_problems, self.wifi_tag_problems]
        for idx, problems in enumerate(all_problems):
            print()
            self.__print_problem_summary(problems, idx_from=tbl_idx_from, verbose=verbose, panel_title=f"Consistency Check Report ({idx+1})")
            #tbl_idx_from += len(problems)
            tbl_idx_from += 10


    def __print_problem_summary(self, problems, idx_from=0, verbose=False, use_panel=True, panel_title="") -> None:
        table = Table(show_header=True, header_style="bold red")
        table.box = box.SIMPLE
        #table.row_styles = ["none", "dim"]
        table.add_column("#", style="dim")
        table.add_column("Hostname", style="bold")
        table.add_column("IP address", style="dim")
        table.add_column("Interface", style="bold")
        table.add_column("Violation", style="cyan")
        if verbose:
            table.add_column("Current state", style="magenta")
            table.add_column("Desired state", style="green")

        for i in range(10):
            d = [str(idx_from+i), "s7-flets", "172.16.32.133", "GigabitEthernet0/1/20", "Master/Slave"]
            if verbose:
                d.extend([
                    "[bold]VLAN:[/bold]  100, 120, 300, 310, 330\n[bold]PoE:[/bold]   Enabled\n[bold]Speed:[/bold] Auto",
                    "[bold]VLAN:[/bold]  100, 120, 300, 310, 330\n[bold]PoE:[/bold]   Enabled\n[bold]Speed:[/bold] Auto",
                ])
            table.add_row(*d)

        if use_panel:
            self.console.print(Panel.fit(table, title=panel_title))
        else:
            self.console.print(table)


    def __flatten_num_string(self, nstr) -> list:
        l = []
        for n in nstr.split():
            if "-" in n:
                a, b = map(int, n.split("-"))
                l.extend([i for i in range(a,b+1)])
            else:
                l.append(int(n))
        return l


    def full_repair(self, skip_confirm=False, verbose=False) -> None:
        is_confirmed = skip_confirm
        skipped_idc = []

        print()
        if skip_confirm:
            with self.console.status("[bold]Performing force repair in 5 seconds..."):
                sleep(5)
        else:
            nstr = Prompt.ask("Skip to repair (eg: 1 2 3-5)")
            skipped_idc = self.__flatten_num_string(nstr)
            is_confirmed = Confirm.ask(
                f"You are about to force repair [red]{self.n_total_problems - len(skipped_idc)}[/red] interfaces. Continue?",
                default=False
            )
            print()
            if not is_confirmed:
                self.console.log("Aborted")
                sys.exit(0)

        with self.console.status("[bold]Repairing broken master/slave tag consistency..."):
            self.__repair(self.master_slave_tag_problems)
            self.console.log("Repaired all Master/Slave tag inconsistencies")

        with self.console.status("[bold]Repairing broken Wi-Fi tag consistency..."):
            self.__repair(self.wifi_tag_problems)
            self.console.log("Repaired all Wi-Fi tag inconsistencies")


    def __repair(self, problems) -> None:
        sleep(0.5)  # dummy


    def __check_master_slave_tag_consistency(self) -> None:
        sleep(0.5)  # dummy
        self.master_slave_tag_problems = [{}]


    def __check_wifi_tag_consistency(self) -> None:
        sleep(0.5)  # dummy
        self.wifi_tag_problems = [{}]


@click.command(help="A command-line utility to check and repair NetBox integrity and consistency")
@click.option("--force-repair", "flg_force_repair", is_flag=True, default=False, help="Repair all inconsistencies without confirmation")
@click.option("--verbose", "flg_verbose", is_flag=True, default=False, help="Show defailed logging")
def main(flg_force_repair, flg_verbose):
    nbck = NBCK()
    nbck.load_inventories(verbose=flg_verbose)
    nbck.full_check(verbose=flg_verbose)
    nbck.full_repair(skip_confirm=flg_force_repair, verbose=flg_verbose)


if __name__ == "__main__":
    main()
