#!/usr/bin/env python3

"""

NBCK - NetBox Consistency Check

NBCK is a command-line utility to check and repair NetBox registration errors.
This makes sure NetBox for integrity and consistency just like the fsck command does for Linux filesystem.

$ PATH=$HOME/tn4-player/bin:$PATH
$ nbck -fv

Since: March 2022
See: https://github.com/yamaoka-kitaguchi-lab/tn4-player

"""

from rich import box
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Prompt, Confirm
from rich.table import Table
from time import sleep
import click
import copy
import json
import os
import re
import sys

CURDIR = os.path.dirname(os.path.abspath(__file__))
sys.path.append(os.path.join(CURDIR, "../netbox"))

from netbox import NetBoxClient, load_encrypted_secrets


class NBCK:
    def __init__(self, nb) -> None:
        self.nb = nb
        self.console = Console(log_time_format="%Y-%m-%dT%H:%M:%S")
        self.n_total_problems = 0
        self.core_downstream_problems = None
        self.master_slave_tag_problems = None
        self.wifi_tag_problems = None


    def load_inventories_for_debug(self, verbose=False) -> None:
        for cache in [".sites.cache", ".vlans.cache", ".addresses.cache", ".devices.cache", ".interfaces.cache"]:
            if not os.path.exists(cache):
                self.load_inventories(verbose=verbose)
                with open(".sites.cache", "w") as fd:
                    json.dump(self.nb.all_sites, fd)
                with open(".vlans.cache", "w") as fd:
                    json.dump(self.nb.all_vlans, fd)
                with open(".addresses.cache", "w") as fd:
                    json.dump(self.nb.all_addresses, fd)
                with open(".devices.cache", "w") as fd:
                    json.dump(self.nb.all_devices, fd)
                with open(".interfaces.cache", "w") as fd:
                    json.dump(self.nb.all_interfaces, fd)
                break

        with open(".sites.cache") as fd:
            self.nb.all_sites = json.load(fd)
            self.console.log(f"Fetched all Sites ({len(self.nb.all_sites)} sites fetched)")
        with open(".vlans.cache") as fd:
            self.nb.all_vlans = json.load(fd)
            self.console.log(f"Fetched all VLANs ({len(self.nb.all_vlans)} VLANs fetched)")
        with open(".addresses.cache") as fd:
            self.nb.all_addresses = json.load(fd)
            self.console.log(f"Fetched all IP Addresses ({len(self.nb.all_addresses)} addresses fetched)")
        with open(".devices.cache") as fd:
            self.nb.all_devices = json.load(fd)
            self.console.log(f"Fetched all Devices ({len(self.nb.all_devices)} devices fetched)")
        with open(".interfaces.cache") as fd:
            self.nb.all_interfaces = json.load(fd)
            n = sum(len(v) for v in self.nb.all_interfaces.values())
            self.console.log(f"Fetched all Interfaces ({n} interfaces fetched)")


    def load_inventories(self, verbose=False) -> None:
        self.console.log("NBCK - NetBox Consistency Check")
        self.console.log(f"API endpoint: {self.nb.netbox_url}")
        with self.console.status("[bold]Fetching the latest inventories from NetBox..."):
            self.nb.get_all_sites()
            self.console.log(f"Fetched all Sites ({len(self.nb.all_sites)} sites fetched)")

            self.nb.get_all_vlans()
            self.console.log(f"Fetched all VLANs ({len(self.nb.all_vlans)} VLANs fetched)")

            self.nb.get_all_addresses()
            self.console.log(f"Fetched all IP Addresses ({len(self.nb.all_addresses)} addresses fetched)")

            self.nb.get_all_devices()
            self.console.log(f"Fetched all Devices ({len(self.nb.all_devices)} devices fetched)")

            self.nb.get_all_interfaces()
            n = sum(len(v) for v in self.nb.all_interfaces.values())
            self.console.log(f"Fetched all Interfaces ({n} interfaces fetched)")


    def full_check(self, verbose=False) -> None:
        with self.console.status("[bold]Finding broken consistency..."):
            self.__check_wifi_tag_consistency()
            n_problems = len(self.wifi_tag_problems)
            self.n_total_problems += n_problems
            self.console.log(f"Checked Wi-Fi tag consistency ({n_problems} problems found)")

            self.__check_master_slave_tag_consistency()
            n_problems = len(self.master_slave_tag_problems)
            self.n_total_problems += n_problems
            self.console.log(f"Checked Master/Slave tag consistency ({n_problems} problems found)")

            self.__check_core_downstream_consistency()
            n_problems = len(self.core_downstream_problems)
            self.n_total_problems += n_problems
            self.console.log(f"Checked downstream VLAN consistency ({n_problems} problems found)")

        tbl_idx_from = 0
        all_problems = [self.master_slave_tag_problems, self.wifi_tag_problems]
        for idx, problems in enumerate(all_problems):
            print()
            self.__print_problem_summary(problems, idx_from=tbl_idx_from, verbose=verbose, panel_title=f"Consistency Check Report ({idx+1})")
            #tbl_idx_from += len(problems)
            tbl_idx_from += 10


    def __print_problem_summary(self, problems, idx_from=0, verbose=False, use_panel=True, panel_title="") -> None:
        table = Table(show_header=True, header_style="bold red")
        table.box = box.SIMPLE
        #table.row_styles = ["none", "dim"]
        table.add_column("#", style="dim")
        table.add_column("Hostname", style="bold")
        table.add_column("IP address", style="dim")
        table.add_column("Interface", style="bold")
        table.add_column("Violation", style="cyan")
        if verbose:
            table.add_column("Current state", style="magenta")
            table.add_column("Desired state", style="green")

        for i in range(10):
            d = [str(idx_from+i), "s7-flets", "172.16.32.133", "GigabitEthernet0/1/20", "Master/Slave"]
            if verbose:
                d.extend([
                    "[bold]VLAN:[/bold]  100, 120, 300, 310, 330, 100, 120, 300, 310, 330, \n[bold]PoE:[/bold]   Enabled\n[bold]Speed:[/bold] Auto",
                    "[bold]VLAN:[/bold]  100, 120, 300, 310, 330, 100, 120, 300, 310, 330, \n[bold]PoE:[/bold]   Enabled\n[bold]Speed:[/bold] Auto",
                ])
            table.add_row(*d)

        if use_panel:
            self.console.print(Panel.fit(table, title=panel_title))
        else:
            self.console.print(table)


    def __flatten_num_string(self, nstr) -> list:
        l = []
        for n in nstr.split():
            if "-" in n:
                a, b = map(int, n.split("-"))
                l.extend([i for i in range(a,b+1)])
            else:
                l.append(int(n))
        return l


    def full_repair(self, skip_confirm=False, verbose=False) -> None:
        is_confirmed = skip_confirm
        skipped_idc = []

        print()
        if skip_confirm:
            with self.console.status("[bold]Performing force repair in 5 seconds..."):
                sleep(5)
        else:
            nstr = Prompt.ask("Interfaces to skip repairing (eg: 1 2 3-5)")
            skipped_idc = self.__flatten_num_string(nstr)
            is_confirmed = Confirm.ask(
                f"You are about to force repair [red]{self.n_total_problems - len(skipped_idc)}[/red] interfaces. Continue?",
                default=False
            )
            print()
            if not is_confirmed:
                self.console.log("Aborted")
                sys.exit(0)

        with self.console.status("[bold]Repairing broken master/slave tag consistency..."):
            self.__repair(self.master_slave_tag_problems)
            self.console.log("Repaired all Master/Slave tag inconsistencies")

        with self.console.status("[bold]Repairing broken Wi-Fi tag consistency..."):
            self.__repair(self.wifi_tag_problems)
            self.console.log("Repaired all Wi-Fi tag inconsistencies")


    def __repair(self, problems) -> None:
        sleep(0.5)  # dummy


    def __check_master_slave_tag_consistency(self) -> None:
        sleep(0.5)  # dummy
        self.master_slave_tag_problems = [{}]


    def __check_wifi_tag_consistency(self) -> None:
        sleep(0.5)  # dummy
        self.wifi_tag_problems = [{}]


    def __check_core_downstream_consistency(self) -> None:
        sleep(0.5)  # dummy
        self.core_downstream_problems = [{}]


@click.command(help="A command-line utility to check and repair NetBox integrity and consistency")
@click.option("-f", "--force-repair", "flg_force_repair", is_flag=True, default=False, help="Repair all inconsistencies without confirmation.")
@click.option("-v", "--verbose", "flg_verbose", is_flag=True, default=False, help="Show detailed logging.")
def main(flg_force_repair, flg_verbose):
    secrets = load_encrypted_secrets()
    nb_url = secrets["netbox_url"]
    nb_token = secrets["netbox_api_token"]

    nb = NetBoxClient(nb_url, nb_token)
    nbck = NBCK(nb)
    #nbck.load_inventories(verbose=flg_verbose)
    nbck.load_inventories_for_debug(verbose=flg_verbose)
    nbck.full_check(verbose=flg_verbose)
    nbck.full_repair(skip_confirm=flg_force_repair, verbose=flg_verbose)


def debug():
    from pprint import pprint

    secrets = load_encrypted_secrets()
    nb_url = secrets["netbox_url"]
    nb_token = secrets["netbox_api_token"]
    nb = NetBoxClient(nb_url, nb_token)
    nbck = NBCK(nb)
    nbck.load_inventories_for_debug(verbose=True)

    #pprint(nb.all_sites["minami3"])
    #pprint(nb.all_devices["core-honkan"])
    #pprint(nb.all_devices["minami3 (1)"])
    #pprint(nb.all_interfaces["core-honkan"]["ae103"])
    #pprint(nb.all_interfaces["minami3 (1)"]["ge-0/0/13"])
    #pprint(nb.all_vlans["514"])

    all_desired_interfaces = copy.deepcopy(nb.all_interfaces)

    desired_upstream_vlan_ids = {}  # key: VC hostname, value: list of VLAN object IDs
    for hostname, interfaces in all_desired_interfaces.items():
        l = []
        hostname_reg = re.match("([\w|-]+) \((\d+)\)", hostname)
        if hostname_reg is not None:
            hostname = hostname_reg.group(1)
        for interface in interfaces.values():
            l.extend([v["id"] for v in interface["tagged_vlans"]])
            if interface["untagged_vlan"] is not None:
                l.append(interface["untagged_vlan"]["vid"])
        if hostname in desired_upstream_vlan_ids:
            l.extend(desired_upstream_vlan_ids[hostname])
        desired_upstream_vlan_ids[hostname] = list(set(l))

    #pprint(desired_upstream_vlan_ids)



if __name__ == "__main__":
    #main()
    debug()
